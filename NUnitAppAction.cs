using System;
using System.ComponentModel;
using System.Globalization;
using System.IO;
using System.Xml.Linq;
using Inedo.BuildMaster;
using Inedo.BuildMaster.Extensibility.Actions;
using Inedo.BuildMaster.Extensibility.Actions.Testing;
using Inedo.BuildMaster.Extensibility.Agents;
using Inedo.BuildMaster.Web;
using Inedo.Documentation;
using Inedo.Serialization;

namespace Inedo.BuildMasterExtensions.NUnit
{
    [DisplayName("Execute NUnit Tests")]
    [Description("Runs NUnit unit tests on a specified project, assembly, or NUnit file.")]
    [Tag(Tags.UnitTests)]
    [CustomEditor(typeof(NUnitActionEditor))]
    [RequiresInterface(typeof(IFileOperationsExecuter))]
    [ConvertibleToOperation(typeof(NUnitActionImporter))]
    public sealed class NUnitAppAction : UnitTestActionBase
    {
        /// <summary>
        /// Gets or sets the test runner exe path
        /// </summary>
        [Persistent]
        public string ExePath { get; set; }

        /// <summary>
        /// Gets or sets the file nunit will test against (could be dll, proj, or config file based on test runner)
        /// </summary>
        [Persistent]
        public string TestFile { get; set; }

        /// <summary>
        /// Gets or sets the additional arguments.
        /// </summary>
        [Persistent]
        public string AdditionalArguments { get; set; }

        /// <summary>
        /// Gets or sets the path of the output XML generated by NUnit.
        /// </summary>
        [Persistent]
        public string CustomXmlOutputPath { get; set; }

        /// <summary>
        /// Gets or sets a value indicating whether to treat inconclusive tests as failures.
        /// </summary>
        [Persistent]
        public bool TreatInconclusiveAsFailure { get; set; } = true;

        public override ExtendedRichDescription GetActionDescription()
        {
            var longActionDescription = new RichDescription();
            if (!string.IsNullOrWhiteSpace(this.AdditionalArguments))
            {
                longActionDescription.AppendContent(
                    "with additional arguments: ",
                    new Hilite(this.AdditionalArguments)
                );
            }

            return new ExtendedRichDescription(
                new RichDescription(
                    "Run NUnit on ",
                    new DirectoryHilite(this.OverriddenSourceDirectory, this.TestFile)
                ),
                longActionDescription
            );
        }

        /// <summary>
        /// Runs a unit test against the target specified in the action.
        /// After the test is run, use the <see cref="M:RecordResult" /> method
        /// to save the test results to the database.
        /// </summary>
        protected override void RunTests()
        {
            var fileOps = this.Context.Agent.GetService<IFileOperationsExecuter>();

            var nunitExePath = this.GetNUnitExePath(fileOps);
            var tmpFileName = this.GetXmlOutputPath(fileOps);

            var startTime = DateTime.UtcNow;

            this.ExecuteCommandLine(
                nunitExePath,
                string.Format("\"{0}\" /xml:\"{1}\" {2}", this.TestFile, tmpFileName, this.AdditionalArguments),
                this.Context.SourceDirectory
            );

            XDocument xdoc;
            using (var stream = fileOps.OpenFile(tmpFileName, FileMode.Open, FileAccess.Read))
            {
                xdoc = XDocument.Load(stream);
            }

            var testResultsElement = xdoc.Element("test-results");

            startTime = this.TryParseStartTime((string)testResultsElement.Attribute("date"), (string)testResultsElement.Attribute("time")) ?? startTime;

            foreach (var testCaseElement in xdoc.Descendants("test-case"))
            {
                var testName = (string)testCaseElement.Attribute("name");

                // skip tests that weren't actually run
                if (string.Equals((string)testCaseElement.Attribute("executed"), "False", StringComparison.OrdinalIgnoreCase))
                {
                    this.LogInformation("NUnit test: {0} (skipped)", testName);
                    continue;
                }

                bool nodeResult = string.Equals((string)testCaseElement.Attribute("success"), "True", StringComparison.OrdinalIgnoreCase)
                    || (!this.TreatInconclusiveAsFailure && string.Equals((string)testCaseElement.Attribute("result"), "Inconclusive", StringComparison.OrdinalIgnoreCase));

                var testDuration = this.TryParseTestTime((string)testCaseElement.Attribute("time"));

                this.LogInformation(
                    "NUnit Test: {0}, Result: {1}, Test Length: {2}",
                    testName,
                    nodeResult,
                    testDuration
                );

                this.RecordResult(
                    testName,
                    nodeResult,
                    testCaseElement.ToString(),
                    startTime,
                    startTime + testDuration
                );

                startTime += testDuration;
            }
        }

        private string GetNUnitExePath(IFileOperationsExecuter fileOps)
        {
            if (!string.IsNullOrWhiteSpace(this.ExePath))
                return fileOps.CombinePath(this.Context.SourceDirectory, this.ExePath);

            var configurer = (NUnitConfigurer)this.GetExtensionConfigurer();
            if (string.IsNullOrWhiteSpace(configurer.NUnitConsoleExePath))
                throw new InvalidOperationException("The path to NUnit was not specified in either the action or the selected NUnit extension's configuration.");

            return fileOps.CombinePath(this.Context.SourceDirectory, configurer.NUnitConsoleExePath);
        }

        private string GetXmlOutputPath(IFileOperationsExecuter fileOps)
        {
            if (string.IsNullOrWhiteSpace(this.CustomXmlOutputPath))
                return fileOps.CombinePath(this.Context.TempDirectory, Guid.NewGuid().ToString() + ".xml");

            return fileOps.CombinePath(this.Context.SourceDirectory, this.CustomXmlOutputPath);
        }

        private DateTime? TryParseStartTime(string date, string time)
        {
            try
            {
                if (string.IsNullOrWhiteSpace(date))
                {
                    DateTime result;
                    if (DateTime.TryParse(time, out result))
                        return result.ToUniversalTime();
                }

                if (!string.IsNullOrWhiteSpace(date) && !string.IsNullOrWhiteSpace(time))
                {
                    var dateParts = date.Split('-');
                    var timeParts = time.Split(':');

                    return new DateTime(
                        year: int.Parse(dateParts[0]),
                        month: int.Parse(dateParts[1]),
                        day: int.Parse(dateParts[2]),
                        hour: int.Parse(timeParts[0]),
                        minute: int.Parse(timeParts[1]),
                        second: int.Parse(timeParts[2])
                    ).ToUniversalTime();
                }
            }
            catch
            {
            }

            this.LogWarning("Unable to parse start time; using current time instead.");
            return null;
        }
        private TimeSpan TryParseTestTime(string time)
        {
            if (string.IsNullOrWhiteSpace(time))
                return TimeSpan.Zero;

            var mungedTime = time.Replace(',', '.');
            double doubleTime;
            bool parsed = double.TryParse(
                mungedTime,
                NumberStyles.AllowLeadingWhite | NumberStyles.AllowTrailingWhite | NumberStyles.AllowLeadingSign | NumberStyles.AllowDecimalPoint | NumberStyles.AllowThousands | NumberStyles.AllowExponent,
                CultureInfo.InvariantCulture,
                out doubleTime
            );

            if (!parsed)
                this.LogWarning("Could not parse {0} as a time in seconds.", time);

            return TimeSpan.FromSeconds(doubleTime);
        }
    }
}
